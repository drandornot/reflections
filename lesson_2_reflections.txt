Reflections from lesson 2.

What happens when you initialize a repository? Why do you need to do it?
git init produces an empty repository.  It adds a hidden subdirectory 
called .git to the working directory.  If you don't do this, there will
be no place for your commits to be recorded.

How is the staging area different from the working directory and the repository? 
What value do you think it offers?
The staging area is a list of files that become part of the commit.  
The staging area allows files to be associated with each other so they are
all updated simultaneously during a git commit.  The staging area provides
a means for multiple files to be updated together.

How can you use the staging area to make sure you have one commit per logical change?
I'm not confident about how to answer this question.  I think that every time a
logical change is made, the affected files should be added to the staging area.
If you check status before making the commit, status will tell you what files 
have been changed since the last commit.  All files that have been changed should
be added to the staging area before committing them.

What are some situations when branches would be helpful in keeping your history organized? 
How would branches help?
Branches would be useful when you want to preserve a working version of the source code 
while working out coding a new feature.  Branches help by keeping the source code changes
associated with the feature separate from the main branch.

How do the diagrams help you visualize the branch structure?
The diagrams show chronological order.  This order reflects the parent/child
relationship between commits.  It also shows how branches are separated from 
the master.  In my case, the easy-mode branch did not appear distinct from the
master.  Perhaps this is because no further changes were made to the master after 
adding easy-mode or maybe because the easy-mode branch only contained one commit.






